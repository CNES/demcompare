.. _class_schema:


Demcompare's classes
====================


Demcompare's architecture combines simple python modules with python classes. Some of those classes have an abstract architecture whilst
others don't.

Demcompare's abstract classes are all implemented with two main python files:

- The class factory, which is python file named like the class. It only handles the class object generation.
- The abstract class template, which is a python file named like the class + "_template". This file includes all the abstract functions and attributes.

With the class factory and the abstract class template, the different subclasses can be implemented:

- The subclasses, which are python files implementing the subclasses derived from the abstract class.  


In the following images we can find the classes that take part in demcompare's coregistration and statistics steps, along
with their relationship.

Coregistration step architecture
--------------------------------

.. figure:: /images/schema_coregistration_class.png
    :width: 400px
    :align: center

    Coregistration classes relationship. 


Coregistration
**************

The coregistration class in demcompare has the following structure:

- **Coregistration**: The class Factory. Implemented in `coregistration/coregistration.py`
- **CoregistrationTemplate**: The abstract class. Implemented in `coregistration/coregistration_template.py`
- **NuthKaabInternal**: Nuth et kaab coregistration algorithm. Implemented in `coregistration/nuth_kaab_internal.py`

The coregistration class computes the offsets between two DEMs that have the same resolution and size, giving as an output
a Transformation object, along with the two reprojected and coregistered dems.

Transformation
**************

- **Transformation**: Implemented in `transformation.py`

The Transformation class stores the offsets obtained during the coregistration step. It also has the API to apply the
offsets to an input DEM. It is created by the Coregistration class and given as an output.


Statistics step architecture
----------------------------

.. figure:: /images/schema_statistiques_class.png
    :width: 1100px
    :align: center

    Statistics classes relationship. 


Stats processing
****************

**StatsProcessing**: Implemented in `stats_processing.py`

The StatsProcessing class handles the statistics computation for an input dem. It generates the different ClassificationLayer objects along
with the StatsDataset output object. It also has the API to compute the different statistics.

Classification layer
********************

The classification_layer class in demcompare has the following structure:

- **ClassificationLayer**: The class Factory. Implemented in `classification_layer/classification_layer.py`
- **ClassificationLayerTemplate**: The abstract class. Implemented in `classification_layer/classification_layer_template.py`
- **SegmentationClassification**: Segmentation classification layer class. Implemented in `classification_layer/segmentation_classification.py`
- **GlobalClassification**: Global classification layer class. Implemented in `classification_layer/global_classification.py`
- **SlopeClassification**: Slope classification layer class. Implemented in `classification_layer/slope_classification.py`
- **FusionClassification**: Fusion classification layer class. Implemented in `classification_layer/fusion_classification.py`

The classification layers classify the input DEM's pixels by classes in order to obtain statistics by class.

Metric
******

The metric class in demcompare has the following structure:

- **Metric**: The class Factory. Implemented in `metric/metric.py`
- **MetricTemplate**: The abstract class. Implemented in `metric/metric_template.py`

- Metric classes implemented in `metric/scalar_metrics.py`

    - **Mean**
    - **Max**
    - **Min**
    - **Std**
    - **Rmse**
    - **Median**
    - **Nmad**
    - **Sum**
    - **Squared_sum**
    - **Percentil90**

Each scalar metric computes a scalar value based on the input data.

- Metric classes implemented in `metric/vector_metrics.py`

    - **Cdf**
    - **Pdf**
    - **RatioAboveThreshold**

Each vector metric computes two arrays of values based on the input data.


Stats dataset
*************

**StatsDataset**: Implemented in `stats_dataset.py`

The StatsDataset class stores the different statistics computed for an input DEM. It is generated by the StatsProcessing class and its architecture
consists in a list of `xr.Dataset`, one for each classification layer that has been used to compute the stats.
It also has the API to obtain the stored statistics.


The statistics of each classification layer are stored in the `xr.Dataset` with the following structure:

.. code-block:: text

    :image: 2D (row, col) input image as xarray.DataArray,

    :image_by_class: 3D (row, col, nb_classes)

        xarray.DataArray containing
        the image pixels belonging
        to each class considering the valid pixels

    :image_by_class_intersection: 3D (row, col, nb_classes)

        xarray.DataArray containing
        the image pixels belonging
        to each class considering the intersection mode

    :image_by_class_exclusion: 3D (row, col, nb_classes)

        xarray.DataArray containing
        the image pixels belonging
        to each class considering the exclusion mode

    :attributes:

                - name : name of the classification_layer. str

                - stats_by_class : dictionary containing
                  the stats per class considering the standard mode

                - stats_by_class_intersection : dictionary containing
                  the stats per class considering the intersection mode

                - stats_by_class_exclusion : dictionary containing
                  the stats per class considering the exclusion mode
